"""CMake file generator visitor module."""

__author__ = "sgu"

#  Copyright (c) 2023.  OceanDSL (https://oceandsl.uni-kiel.de)
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
# util
from typing import Dict, List, Tuple

# jinja2
from jinja2 import Environment, FileSystemLoader

# user relative imports
from ..filewriter.file_writer import write_file
from ..gen.python.TestSuite.TestSuiteParser import TestSuiteParser
from ..symboltable.symbol_table import SymbolTable, TestCaseSymbol
from ..gen.python.TestSuite.TestSuiteVisitor import TestSuiteVisitor
from ..utils.suggest_variables import get_scope


class CMakeFileGeneratorVisitor(TestSuiteVisitor):
    symbol_table: SymbolTable
    work_path: str
    cwd: str

    def __init__(
            self, template_path: str = "tdd-dsl/tddlspserver/filewriter/jinjatemplates/cmake", files: Dict[str, Tuple[float, str, str]] = {},
            symbol_table: SymbolTable = None, work_path: str = "tdd-dsl/output"
    ):
        """
        Generate CMake files for test case

        :param template_path: system path to jinja templates
        :param files: File attributes of files generated by the tdd-dsl server
        :param symbol_table: Symbol table to resolve symbols of tdd-dsl server
        :param work_path: system path to generate test suite
        """
        super().__init__()

        self.overwrite = False
        self.overwrite_files: List[str] = []
        self.files: dict[str, Tuple[float, str, str]] = files

        self.symbol_table = symbol_table

        self.template_path = template_path

        # Load Jinja2 templates
        self.template_env = Environment(loader=FileSystemLoader(template_path), trim_blocks=True, lstrip_blocks=True, keep_trailing_newline=True)

        self.work_path = work_path
        self.cwd = work_path

        self.file_templates = {}
        # Get template file names from grammar
        i: int = 0
        for rule in TestSuiteParser.ruleNames:
            self.file_templates[i] = f"{rule}_template.txt"
            i += 1

    # Visit a parse tree produced by TestSuiteParser#test_suite.
    def visitTest_suite(self, ctx: TestSuiteParser.Test_suiteContext):

        suts = {}
        sut_names = []
        sut: Tuple = ()
        test_dirs = []
        # Initialize test suite overwrite flag as default
        overwrite = self.overwrite
        for case in ctx.cases:
            test_case = self.visit(case)

            test_case_name: str = test_case[0]
            test_case_symbol: TestCaseSymbol = test_case[1]

            # Add name file mapping
            suts[test_case_name] = test_case_symbol.include_files

            # Add test directory
            test_file = os.path.split(test_case_symbol.test_file_path)
            rel_test_dir = os.path.relpath(test_file[0], self.work_path)
            rel_test_dir = rel_test_dir if rel_test_dir != "." else None

            test_dirs.append(rel_test_dir)

            # Update test suite overwrite flag
            overwrite: bool = test_case[2] or overwrite

        # Load Jinja2 template
        template = self.template_env.get_template(self.file_templates[ctx.getRuleIndex()])

        # # Set CMake file path to project folder
        abs_path: str = os.path.join(self.work_path, "CMakeLists.txt")


        driver_path: str = os.path.join(self.work_path, "build_with_cmake_and_run.x")
        if not os.path.isfile(driver_path):
            # Write driver if it doesn't exist
            driver_template = self.template_env.get_template("driver.txt")
            with open(driver_path, mode="w", encoding="utf-8") as f: f.write(driver_template.render())

        # Check if file exists and need to be merged
        if os.path.exists(abs_path) and not overwrite:
            # Generate parts to be merged into
            insert = True

            # Update sut with CMake statements
            for sut_name, sut_files in suts.items():

                # Set template variables
                template_vars = {
                    "SUTNAME": sut_name,
                    "SUTFILENAMES": sut_files,
                    "RENDER_TEMPLATE": "add_library"
                }

                # Render add_library statement
                library_statement = template.render(template_vars)

                # Update template render switch
                template_vars["RENDER_TEMPLATE"] = "target_include"

                # Render target_include statement
                target_include_statement = template.render(template_vars)

                # Update sut mapping
                suts[sut_name] = [library_statement, target_include_statement]

            # Forward statements to file writer
            content = suts

        else:
            # Generate new file
            insert = False

            # Set template variables
            template_vars = {
                "PROJECTNAME": ctx.name.text,
                "SUTS": suts,
                "TESTFOLDERS": test_dirs,
                "RENDER_TEMPLATE": "new"
            }

            # Render template
            content = template.render(template_vars)

        # Write the rendered content to files
        file_attr = self.files.get(abs_path)
        self.files[abs_path] = write_file(abs_path, content, file_attr, insert)

        return self.files

    # Visit a parse tree produced by TestSuiteParser#test_case.
    def visitTest_case(self, ctx: TestSuiteParser.Test_caseContext):

        # Update project path
        # TODO mv to suite
        self.visit(ctx.srcpath)

        # Resolve test case symbol
        test_case_symbol: TestCaseSymbol = get_scope(ctx, self.symbol_table)

        # Get system file paths
        test_file = os.path.split(test_case_symbol.test_file_path)

        # Set sut name according to test name
        sut_name = f"{test_case_symbol.test_name}_sut"

        # Load Jinja2 template
        template = self.template_env.get_template(self.file_templates[ctx.getRuleIndex()])

        # Set CMake file path to test folder
        abs_path: str = os.path.join(test_file[0], "CMakeLists.txt")

        # Set template variables
        template_vars = {
            "SUTNAME": sut_name,
            "TESTNAME": test_case_symbol.test_name,
            "TESTFILENAME": test_file[1],
            "RENDER_TEMPLATE": ""
        }

        # Check test flags. E.g. overwrite flag
        self.overwrite = False
        if ctx.test_flags:
            self.visit(ctx.test_flags)

        if self.overwrite:
            # Merge all files that should overwrite other files

            if abs_path in self.overwrite_files:
                self.overwrite = False
            else:
                self.overwrite_files.append(abs_path)

        # Check if file exists and need to be merged
        if os.path.exists(abs_path) and not self.overwrite:
            # Generate parts to be merged into
            insert = True

            # Render pfunit template
            template_vars["RENDER_TEMPLATE"] = "add_pfunit"
            content = template.render(template_vars)

            # Forward test name with test statement to file writer
            tests = {test_case_symbol.test_name: [content]}
            content = tests

        else:
            # Generate new file
            insert = False

            # Render new template
            template_vars["RENDER_TEMPLATE"] = "new"
            content = template.render(template_vars)

        # Write the rendered content to files
        file_attr = self.files.get(abs_path)
        self.files[abs_path] = write_file(abs_path, content, file_attr, insert)

        # Return system under test details
        sut: Tuple = (sut_name, test_case_symbol, self.overwrite)

        return sut

    # Save the source path to scan for existing variables
    def visitSrc_path(self, ctx: TestSuiteParser.Src_pathContext):
        # Strip string terminals
        user_path: str = ctx.path.text.strip("\'")

        # TODO document
        # Update source directory
        # If the given path is an absolute path, then self._testPath is ignored and the joining is only the given path
        self.work_path = os.path.join(self.cwd, user_path)

    # Visit a parse tree produced by TestSuiteParser#overwritePF.
    def visitOverwriteCMake(self, ctx: TestSuiteParser.OverwritePFContext):
        self.overwrite = True
